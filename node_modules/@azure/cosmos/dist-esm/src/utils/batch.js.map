{"version":3,"file":"batch.js","sourceRoot":"","sources":["../../../src/utils/batch.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { JSONObject } from \"../queryExecutionContext\";\nimport { extractPartitionKey } from \"../extractPartitionKey\";\nimport { PartitionKeyDefinition } from \"../documents\";\nimport { RequestOptions } from \"..\";\nimport { PatchRequestBody } from \"./patch\";\nimport { v4 } from \"uuid\";\nimport { bodyFromData } from \"../request/request\";\nimport { Constants } from \"../common/constants\";\nconst uuid = v4;\n\nexport type Operation =\n  | CreateOperation\n  | UpsertOperation\n  | ReadOperation\n  | DeleteOperation\n  | ReplaceOperation\n  | BulkPatchOperation;\n\nexport interface Batch {\n  min: string;\n  max: string;\n  rangeId: string;\n  indexes: number[];\n  operations: Operation[];\n}\n\nexport interface OperationResponse {\n  statusCode: number;\n  requestCharge: number;\n  eTag?: string;\n  resourceBody?: JSONObject;\n}\n\n/**\n * Options object used to modify bulk execution.\n * continueOnError (Default value: false) - Continues bulk execution when an operation fails ** NOTE THIS WILL DEFAULT TO TRUE IN the 4.0 RELEASE\n */\nexport interface BulkOptions {\n  continueOnError?: boolean;\n}\n\nexport function isKeyInRange(min: string, max: string, key: string): boolean {\n  const isAfterMinInclusive = key.localeCompare(min) >= 0;\n  const isBeforeMax = key.localeCompare(max) < 0;\n  return isAfterMinInclusive && isBeforeMax;\n}\n\nexport interface OperationBase {\n  partitionKey?: string;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n}\n\nexport const BulkOperationType = {\n  Create: \"Create\",\n  Upsert: \"Upsert\",\n  Read: \"Read\",\n  Delete: \"Delete\",\n  Replace: \"Replace\",\n  Patch: \"Patch\",\n} as const;\n\nexport type OperationInput =\n  | CreateOperationInput\n  | UpsertOperationInput\n  | ReadOperationInput\n  | DeleteOperationInput\n  | ReplaceOperationInput\n  | PatchOperationInput;\n\nexport interface CreateOperationInput {\n  partitionKey?: string | number | null | Record<string, unknown> | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Create;\n  resourceBody: JSONObject;\n}\n\nexport interface UpsertOperationInput {\n  partitionKey?: string | number | null | Record<string, unknown> | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Upsert;\n  resourceBody: JSONObject;\n}\n\nexport interface ReadOperationInput {\n  partitionKey?: string | number | boolean | null | Record<string, unknown> | undefined;\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n}\n\nexport interface DeleteOperationInput {\n  partitionKey?: string | number | null | Record<string, unknown> | undefined;\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n}\n\nexport interface ReplaceOperationInput {\n  partitionKey?: string | number | null | Record<string, unknown> | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Replace;\n  resourceBody: JSONObject;\n  id: string;\n}\n\nexport interface PatchOperationInput {\n  partitionKey?: string | number | null | Record<string, unknown> | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Patch;\n  resourceBody: PatchRequestBody;\n  id: string;\n}\n\nexport type OperationWithItem = OperationBase & {\n  resourceBody: JSONObject;\n};\n\nexport type CreateOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Create;\n};\n\nexport type UpsertOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Upsert;\n};\n\nexport type ReadOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n};\n\nexport type DeleteOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n};\n\nexport type ReplaceOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Replace;\n  id: string;\n};\n\nexport type BulkPatchOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Patch;\n  id: string;\n};\n\nexport function hasResource(\n  operation: Operation\n): operation is CreateOperation | UpsertOperation | ReplaceOperation {\n  return (\n    operation.operationType !== \"Patch\" &&\n    (operation as OperationWithItem).resourceBody !== undefined\n  );\n}\n\nexport function getPartitionKeyToHash(operation: Operation, partitionProperty: string): any {\n  const toHashKey = hasResource(operation)\n    ? deepFind(operation.resourceBody, partitionProperty)\n    : (operation.partitionKey && operation.partitionKey.replace(/[[\\]\"']/g, \"\")) ||\n      operation.partitionKey;\n  // We check for empty object since replace will stringify the value\n  // The second check avoids cases where the partitionKey value is actually the string '{}'\n  if (toHashKey === \"{}\" && operation.partitionKey === \"[{}]\") {\n    return {};\n  }\n  if (toHashKey === \"null\" && operation.partitionKey === \"[null]\") {\n    return null;\n  }\n  if (toHashKey === \"0\" && operation.partitionKey === \"[0]\") {\n    return 0;\n  }\n  return toHashKey;\n}\n\nexport function decorateOperation(\n  operation: OperationInput,\n  definition: PartitionKeyDefinition,\n  options: RequestOptions = {}\n): Operation {\n  if (\n    operation.operationType === BulkOperationType.Create ||\n    operation.operationType === BulkOperationType.Upsert\n  ) {\n    if (\n      (operation.resourceBody.id === undefined || operation.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operation.resourceBody.id = uuid();\n    }\n  }\n  if (\"partitionKey\" in operation) {\n    const extracted = extractPartitionKey(operation, { paths: [\"/partitionKey\"] });\n    return { ...operation, partitionKey: JSON.stringify(extracted) } as Operation;\n  } else if (\n    operation.operationType === BulkOperationType.Create ||\n    operation.operationType === BulkOperationType.Replace ||\n    operation.operationType === BulkOperationType.Upsert\n  ) {\n    const pk = extractPartitionKey(operation.resourceBody, definition);\n    return { ...operation, partitionKey: JSON.stringify(pk) } as Operation;\n  } else if (\n    operation.operationType === BulkOperationType.Read ||\n    operation.operationType === BulkOperationType.Delete\n  ) {\n    return { ...operation, partitionKey: \"[{}]\" };\n  }\n  return operation as Operation;\n}\n\n/**\n * Splits a batch into array of batches based on cumulative size of its operations by making sure\n * cumulative size of an individual batch is not larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}.\n * If a single operation itself is larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}, that\n * operation would be moved into a batch containing only that operation.\n * @param originalBatch - A batch of operations needed to be checked.\n * @returns\n * @hidden\n */\nexport function splitBatchBasedOnBodySize(originalBatch: Batch): Batch[] {\n  if (originalBatch?.operations === undefined || originalBatch.operations.length < 1) return [];\n  let currentBatchSize = calculateObjectSizeInBytes(originalBatch.operations[0]);\n  let currentBatch: Batch = {\n    ...originalBatch,\n    operations: [originalBatch.operations[0]],\n    indexes: [originalBatch.indexes[0]],\n  };\n  const processedBatches: Batch[] = [];\n  processedBatches.push(currentBatch);\n\n  for (let index = 1; index < originalBatch.operations.length; index++) {\n    const operation = originalBatch.operations[index];\n    const currentOpSize = calculateObjectSizeInBytes(operation);\n    if (currentBatchSize + currentOpSize > Constants.DefaultMaxBulkRequestBodySizeInBytes) {\n      currentBatch = {\n        ...originalBatch,\n        operations: [],\n        indexes: [],\n      };\n      processedBatches.push(currentBatch);\n      currentBatchSize = 0;\n    }\n    currentBatch.operations.push(operation);\n    currentBatch.indexes.push(originalBatch.indexes[index]);\n    currentBatchSize += currentOpSize;\n  }\n  return processedBatches;\n}\n\n/**\n * Calculates size of an JSON object in bytes with utf-8 encoding.\n * @hidden\n */\nexport function calculateObjectSizeInBytes(obj: unknown): number {\n  return new TextEncoder().encode(bodyFromData(obj as any)).length;\n}\n\nexport function decorateBatchOperation(\n  operation: OperationInput,\n  options: RequestOptions = {}\n): Operation {\n  if (\n    operation.operationType === BulkOperationType.Create ||\n    operation.operationType === BulkOperationType.Upsert\n  ) {\n    if (\n      (operation.resourceBody.id === undefined || operation.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operation.resourceBody.id = uuid();\n    }\n  }\n  return operation as Operation;\n}\n/**\n * Util function for finding partition key values nested in objects at slash (/) separated paths\n * @hidden\n */\nexport function deepFind<T, P extends string>(document: T, path: P): string | JSONObject {\n  const apath = path.split(\"/\");\n  let h: any = document;\n  for (const p of apath) {\n    if (p in h) h = h[p];\n    else {\n      if (p !== \"_partitionKey\") {\n        console.warn(`Partition key not found, using undefined: ${path} at ${p}`);\n      }\n      return \"{}\";\n    }\n  }\n  return h;\n}\n"]}